#!/usr/bin/env tsx
/**
 * Test: Claim #1 (Lacy wallet) - 500 MILO
 */

import { keccak_256 } from '@noble/hashes/sha3.js';
import crypto from 'crypto';
import fs from 'fs';
import {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  sendAndConfirmTransaction,
  ComputeBudgetProgram,
} from '@solana/web3.js';
import { getAssociatedTokenAddressSync, TOKEN_2022_PROGRAM_ID } from '@solana/spl-token';

// Mainnet config
const RPC_URL = 'https://mainnet.helius-rpc.com/?api-key=1fc5da66-dd53-4041-9069-7300d1787973
const PROGRAM_ID = new PublicKey('4rArjoSZKrYkoE7hkvZNBP2Wpxovr78cfkxBnNwFNPn5');
const MINT = new PublicKey('AAHd7u22jCMgmbF7ATkiY3BhkifD4MN3Vbsy4eYQGWN5');

// Load epoch data
const epochData = JSON.parse(fs.readFileSync('/tmp/milo-epoch-0.json', 'utf8'));
const { epoch, root: rootHex, claims } = epochData;

console.log('üß™ MILO Test: Claim #1 (Lacy Wallet)');
console.log(`üìç Epoch: ${epoch}`);
console.log(`üìç Root: ${rootHex}`);
console.log(`üìç Claims: ${claims.length}`);

// Merkle tree helper
function makeClaimLeaf(index: number, amount: number, id: string): Uint8Array {
  const indexBytes = Buffer.alloc(4);
  indexBytes.writeUInt32LE(index, 0);

  const amountBytes = Buffer.alloc(8);
  amountBytes.writeBigUInt64LE(BigInt(amount), 0);

  const idBytes = Buffer.from(id, 'utf8');
  const preimage = Buffer.concat([indexBytes, amountBytes, idBytes]);
  return keccak_256(preimage);
}

function generateProof(leaves: Uint8Array[], targetIndex: number): string[] {
  const proof: string[] = [];
  let level = [...leaves];
  let index = targetIndex;

  while (level.length > 1) {
    const nextLevel: Uint8Array[] = [];
    for (let i = 0; i < level.length; i += 2) {
      const left = level[i];
      const right = level[i + 1] || left;

      // If current index is at this position, record sibling
      if (i === index || i + 1 === index) {
        const sibling = (i === index) ? right : left;
        proof.push(Buffer.from(sibling).toString('hex'));
      }

      const [first, second] = Buffer.compare(Buffer.from(left), Buffer.from(right)) <= 0
        ? [left, right]
        : [right, left];
      nextLevel.push(keccak_256(Buffer.concat([first, second])));
    }
    level = nextLevel;
    index = Math.floor(index / 2);
  }

  return proof.map(p => '0x' + p);
}

async function main() {
  // Claim #1: Lacy
  const claim = claims[1];
  const { id, amount, index } = claim;

  console.log(`\nüë§ Claimer: ${id}`);
  console.log(`üí∞ Amount: ${Number(amount) / 1e9} MILO`);
  console.log(`üî¢ Index: ${index}`);

  // Generate proof
  const leaves = claims.map((c: any) => makeClaimLeaf(c.index, c.amount, c.id));
  const proof = generateProof(leaves, index);

  console.log(`\nüå≥ Merkle Proof (${proof.length} siblings):`);
  proof.forEach((p, i) => console.log(`  ${i}: ${p}`));

  // Generate test keypair for Lacy (since we don't have actual keypair)
  const lacyKeypair = Keypair.generate();
  console.log(`\nüîë Test wallet: ${lacyKeypair.publicKey.toBase58()}`);
  console.log(`   (Using test wallet instead of actual Lacy pubkey)`);

  // Derive PDAs
  const epochBytesLE = Buffer.alloc(8);
  epochBytesLE.writeBigUInt64LE(BigInt(epoch), 0);

  const adminKey = new PublicKey('AmMftc4zHgR4yYfv29awV9Q46emo2aGPFW8utP81CsBv'); // Streamer = admin

  const [epochStatePDA] = PublicKey.findProgramAddressSync(
    [Buffer.from('epoch_state'), epochBytesLE, adminKey.toBuffer()],
    PROGRAM_ID
  );

  const [protocolStatePDA] = PublicKey.findProgramAddressSync(
    [Buffer.from('protocol')],
    PROGRAM_ID
  );

  // Treasury ATA (owned by protocol_state PDA)
  const treasuryATA = getAssociatedTokenAddressSync(MINT, protocolStatePDA, true, TOKEN_2022_PROGRAM_ID);

  // Claimer ATA
  const claimerATA = getAssociatedTokenAddressSync(MINT, lacyKeypair.publicKey, false, TOKEN_2022_PROGRAM_ID);

  console.log(`\nüìç Epoch State PDA: ${epochStatePDA.toBase58()}`);
  console.log(`üìç Treasury ATA: ${treasuryATA.toBase58()}`);
  console.log(`üìç Claimer ATA: ${claimerATA.toBase58()}`);

  // Build claim instruction
  // Signature: claim(streamer_index: u8, index: u32, amount: u64, id: String, proof: Vec<[u8; 32]>)
  const discriminator = crypto.createHash('sha256').update('global:claim').digest().slice(0, 8);

  const streamerIndexByte = Buffer.from([0]); // streamer_index = 0

  const indexBytes = Buffer.alloc(4);
  indexBytes.writeUInt32LE(index, 0);

  const amountBytes = Buffer.alloc(8);
  amountBytes.writeBigUInt64LE(BigInt(amount), 0);

  // Encode id string (length prefix + bytes)
  const idBytes = Buffer.from(id, 'utf8');
  const idLenBytes = Buffer.alloc(4);
  idLenBytes.writeUInt32LE(idBytes.length, 0);

  // Encode proof Vec<[u8; 32]> (length prefix + flattened 32-byte chunks)
  const proofLenBytes = Buffer.alloc(4);
  proofLenBytes.writeUInt32LE(proof.length, 0);
  const proofBytes = Buffer.concat(proof.map(p => Buffer.from(p.slice(2), 'hex')));

  const data = Buffer.concat([
    discriminator,
    streamerIndexByte,
    indexBytes,
    amountBytes,
    idLenBytes,
    idBytes,
    proofLenBytes,
    proofBytes,
  ]);

  // Get ATA program
  const ATA_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');

  const instruction = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: lacyKeypair.publicKey, isSigner: true, isWritable: true }, // claimer (signer, mut)
      { pubkey: protocolStatePDA, isSigner: false, isWritable: true }, // protocol_state (mut)
      { pubkey: epochStatePDA, isSigner: false, isWritable: true }, // epoch_state (mut)
      { pubkey: MINT, isSigner: false, isWritable: false }, // mint
      { pubkey: treasuryATA, isSigner: false, isWritable: true }, // treasury_ata (mut)
      { pubkey: claimerATA, isSigner: false, isWritable: true }, // claimer_ata (mut)
      { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, // token_program
      { pubkey: ATA_PROGRAM_ID, isSigner: false, isWritable: false }, // associated_token_program
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }, // system_program
    ],
    data,
  });

  // Send transaction (will fail - need to fund test wallet first)
  const connection = new Connection(RPC_URL, 'confirmed');

  console.log(`\nüí∏ Funding test wallet with 0.01 SOL...`);
  const adminKeypair = Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(fs.readFileSync('/home/twzrd/milo-token/keys/admin-keypair.json', 'utf8')))
  );

  const fundTx = new Transaction().add(
    SystemProgram.transfer({
      fromPubkey: adminKeypair.publicKey,
      toPubkey: lacyKeypair.publicKey,
      lamports: 10_000_000, // 0.01 SOL
    })
  );

  const fundSig = await sendAndConfirmTransaction(connection, fundTx, [adminKeypair], {
    commitment: 'confirmed',
  });
  console.log(`   Funded: ${fundSig.slice(0, 8)}...`);

  const tx = new Transaction();
  tx.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 400_000 }));
  tx.add(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 50_000 }));
  tx.add(instruction);

  console.log(`\nüöÄ Claiming 500 MILO...`);
  try {
    const sig = await sendAndConfirmTransaction(connection, tx, [lacyKeypair], {
      commitment: 'confirmed',
    });

    console.log(`\n‚úÖ CLAIM SUCCESSFUL!`);
    console.log(`   TX: ${sig}`);
    console.log(`   Explorer: https://explorer.solana.com/tx/${sig}`);

    // Check balance
    const balance = await connection.getTokenAccountBalance(claimerATA);
    console.log(`\nüí∞ New Balance: ${Number(balance.value.amount) / 1e9} MILO`);
  } catch (err: any) {
    console.error(`\n‚ùå Claim failed:`, err.message);
    if (err.logs) {
      console.log('\nProgram logs:');
      err.logs.forEach((log: string) => console.log('  ', log));
    }
  }
}

main().catch(console.error);
